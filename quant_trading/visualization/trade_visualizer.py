"""Tkinter GUI for inspecting cached backtest results."""

from __future__ import annotations

import argparse
import json
import re
import tkinter as tk
from dataclasses import dataclass
from tkinter import messagebox, ttk
from pathlib import Path
from typing import Any, Dict, List, Sequence

import mplfinance as mpf
import numpy as np
import pandas as pd
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg


@dataclass
class CachedBacktest:
    """Data bundle returned by :class:`BacktestCacheRepository`."""

    metadata: Dict[str, Any]
    prices: pd.DataFrame
    trades: List[Dict[str, Any]]


class BacktestCacheRepository:
    """Helper around the JSON files generated by the backtest CLI."""

    def __init__(
        self,
        cache_dir: Path | str = "backtest_results",
        timeframe: str | None = "5m",
    ) -> None:
        self.base_dir = Path(cache_dir)
        self.timeframe: str | None = timeframe.strip().lower() if timeframe else None
        available = self.list_timeframes()
        if not available:
            return
        if self.timeframe not in available:
            self.timeframe = available[0]

    # ------------------------------------------------------------------
    # Discovery helpers
    # ------------------------------------------------------------------
    def list_timeframes(self) -> List[str]:
        if not self.base_dir.exists():
            return []

        timeframes: set[str] = set()
        # First, check for subdirectories such as backtest_results/5m
        for entry in self.base_dir.iterdir():
            if entry.is_dir() and any(entry.glob("*_backtest.json")):
                timeframes.add(entry.name.lower())

        # Also support legacy layout where files live directly under the base directory
        root_files = list(self.base_dir.glob("*_backtest.json"))
        for file in root_files:
            name = file.stem
            parts = name.split("_")
            if len(parts) >= 3:
                candidate = parts[-2].lower()
                timeframes.add(candidate)

        return sorted(timeframes)

    def set_timeframe(self, timeframe: str) -> None:
        self.timeframe = timeframe.strip().lower()

    def _timeframe_dir(self) -> Path:
        if self.timeframe and (self.base_dir / self.timeframe).exists():
            return self.base_dir / self.timeframe
        return self.base_dir

    def _filename_suffix(self) -> str:
        suffix = "_backtest.json"
        if self.timeframe:
            suffix = f"_{self.timeframe}_backtest.json"
        return suffix

    def list_symbols(self) -> List[str]:
        directory = self._timeframe_dir()
        if not directory.exists():
            return []

        suffix = self._filename_suffix()
        symbols: List[str] = []
        for path in sorted(directory.glob("*_backtest.json")):
            if suffix and not path.name.endswith(suffix):
                continue
            symbols.append(path.name.replace(suffix, "").upper())
        return symbols

    # ------------------------------------------------------------------
    # Loading helpers
    # ------------------------------------------------------------------
    def load(self, symbol: str) -> CachedBacktest:
        directory = self._timeframe_dir()
        cache_path = directory / f"{symbol.lower()}{self._filename_suffix()}"
        if not cache_path.exists():
            raise FileNotFoundError(
                f"Cached backtest not found for {symbol} ({cache_path}). "
                "Run 'python -m quant_trading.backtesting.run_backtest' to generate the data first."
            )

        with cache_path.open("r", encoding="utf-8") as handle:
            raw = json.load(handle)

        metadata = self._extract_metadata(raw)
        prices = self._build_price_frame(raw.get("candles"), symbol)
        trades = raw.get("closed_trades", [])
        return CachedBacktest(metadata=metadata, prices=prices, trades=trades)

    @staticmethod
    def _extract_metadata(payload: Dict[str, Any]) -> Dict[str, Any]:
        keys = {
            "symbol",
            "timeframe",
            "start",
            "end",
            "initial_capital",
            "ending_equity",
            "net_profit",
            "return_pct",
            "max_drawdown",
            "total_trades",
            "win_rate",
        }
        return {key: payload.get(key) for key in keys}

    def _build_price_frame(self, candles: List[Dict[str, Any]] | None, symbol: str) -> pd.DataFrame:
        if not candles:
            raise ValueError(
                f"Cached backtest for {symbol} does not contain candle data. "
                "Regenerate cache by re-running 'python -m quant_trading.backtesting.run_backtest'."
            )

        frame = pd.DataFrame(candles)
        if frame.empty:
            raise ValueError(f"Cached candle data for {symbol} is empty.")
        if "datetime" not in frame.columns:
            raise ValueError(f"Cached candle data for {symbol} is missing the 'datetime' column.")

        frame["datetime"] = pd.to_datetime(frame["datetime"], errors="coerce")
        frame = frame.dropna(subset=["datetime"]).sort_values("datetime").set_index("datetime")

        rename_map = {
            "open": "Open",
            "high": "High",
            "low": "Low",
            "close": "Close",
            "volume": "Volume",
        }
        missing = [column for column in rename_map if column not in frame.columns]
        if missing:
            raise ValueError(f"Cached candle data for {symbol} is missing columns: {missing}")

        prices = frame[list(rename_map.keys())].rename(columns=rename_map)
        for col in prices.columns:
            prices[col] = pd.to_numeric(prices[col], errors="coerce")
        prices = prices.dropna(subset=["Close"])
        if prices.empty:
            raise ValueError(f"Cached candle data for {symbol} does not contain valid price rows.")
        return prices


def _timeframe_to_minutes(timeframe: str | None) -> int | None:
    if not timeframe:
        return None
    match = re.match(r"(\d+)([a-zA-Z]+)", timeframe.strip())
    if not match:
        return None
    value = int(match.group(1))
    unit = match.group(2).lower()
    if unit in {"m", "min", "mins", "minute", "minutes"}:
        return value
    if unit in {"h", "hour", "hours"}:
        return value * 60
    if unit in {"d", "day", "days"}:
        return value * 60 * 24
    return None


class TradeVisualizerApp:
    """Tkinter-based candlestick visualizer for backtested trades."""

    def __init__(
        self,
        root: tk.Tk,
        repository: BacktestCacheRepository,
        *,
        chart_style: str = "yahoo",
        scatter_size: int = 60,
    ) -> None:
        self.root = root
        self.repository = repository
        self.chart_style = chart_style
        self.scatter_size = scatter_size

        self.timeframes = sorted(set(repository.list_timeframes()))
        if not self.timeframes:
            default_tf = repository.timeframe or ""
            if default_tf:
                self.timeframes = [default_tf]

        if not self.timeframes:
            messagebox.showerror(
                "No Data",
                (
                    "No cached backtest files were found under "
                    f"{repository.base_dir}. Please run a backtest first."
                ),
            )

        initial_timeframe = repository.timeframe or (self.timeframes[0] if self.timeframes else "")
        if initial_timeframe and initial_timeframe not in self.timeframes:
            self.timeframes.insert(0, initial_timeframe)

        self.timeframe_var = tk.StringVar(value=initial_timeframe)
        self.symbols = repository.list_symbols()
        self.symbol_var = tk.StringVar(value=self.symbols[0] if self.symbols else "")
        self.summary_var = tk.StringVar(value="Select a symbol and click 'Load Chart'.")
        self.canvas: FigureCanvasTkAgg | None = None

        self._build_layout()

    # ------------------------------------------------------------------
    # UI construction
    # ------------------------------------------------------------------
    def _build_layout(self) -> None:
        control_frame = ttk.Frame(self.root, padding=10)
        control_frame.pack(fill=tk.X)

        ttk.Label(control_frame, text="Timeframe:").pack(side=tk.LEFT)
        self.timeframe_combo = ttk.Combobox(
            control_frame,
            textvariable=self.timeframe_var,
            values=self.timeframes,
            state="readonly",
            width=6,
        )
        self.timeframe_combo.pack(side=tk.LEFT, padx=(0, 5))
        self.timeframe_combo.bind("<<ComboboxSelected>>", self._on_timeframe_changed)

        ttk.Label(control_frame, text="Symbol:").pack(side=tk.LEFT)
        self.symbol_combo = ttk.Combobox(
            control_frame,
            textvariable=self.symbol_var,
            values=self.symbols,
            state="readonly",
            width=10,
        )
        self.symbol_combo.pack(side=tk.LEFT, padx=5)

        load_btn = ttk.Button(control_frame, text="Load Chart", command=self._on_load_clicked)
        load_btn.pack(side=tk.LEFT)

        self.summary_label = ttk.Label(self.root, textvariable=self.summary_var, padding=(10, 5))
        self.summary_label.pack(fill=tk.X)

        self.chart_frame = ttk.Frame(self.root)
        self.chart_frame.pack(fill=tk.BOTH, expand=True)

    # ------------------------------------------------------------------
    # Core functionality
    # ------------------------------------------------------------------
    def _on_load_clicked(self) -> None:
        symbol = self.symbol_var.get().strip().upper()
        if not symbol:
            messagebox.showwarning("Select Symbol", "Please choose a symbol before loading the chart.")
            return

        try:
            cached = self.repository.load(symbol)
        except FileNotFoundError as exc:
            messagebox.showerror("Cache Missing", str(exc))
            return
        except json.JSONDecodeError as exc:
            messagebox.showerror("Cache Error", f"Failed to parse cached backtest for {symbol}: {exc}")
            return
        except ValueError as exc:
            messagebox.showerror("Cache Error", str(exc))
            return

        addplots = self._build_trade_markers(cached.prices, cached.trades)
        self._render_chart(symbol, cached.prices, addplots)
        self.summary_var.set(self._format_summary(cached.metadata, cached.prices, cached.trades))

    def _on_timeframe_changed(self, _: Any) -> None:
        timeframe = self.timeframe_var.get()
        self.repository.set_timeframe(timeframe)
        self.symbols = self.repository.list_symbols()
        self.symbol_combo["values"] = self.symbols

        if self.symbols:
            self.symbol_var.set(self.symbols[0])
            self.summary_var.set("Select a symbol and click 'Load Chart'.")
        else:
            self.symbol_var.set("")
            messagebox.showwarning(
                "No Symbols",
                (
                    "No cached backtests were found for timeframe "
                    f"'{timeframe}' under {(self.repository.base_dir / timeframe).resolve()}."
                ),
            )

    # ------------------------------------------------------------------
    # Charting helpers
    # ------------------------------------------------------------------
    def _render_chart(
        self,
        symbol: str,
        df_prices: pd.DataFrame,
        addplots: List[mpf.make_addplot],
    ) -> None:
        fig, _ = mpf.plot(
            df_prices,
            type="candle",
            volume=True,
            style=self.chart_style,
            addplot=addplots,
            title=f"{symbol} {self.repository.timeframe.upper()} Candlesticks & Trades",
            ylabel="Price",
            ylabel_lower="Volume",
            returnfig=True,
            figsize=(12, 8),
        )

        if self.canvas is not None:
            self.canvas.get_tk_widget().destroy()

        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def _build_trade_markers(
        self,
        df_prices: pd.DataFrame,
        closed_trades: List[Dict[str, Any]],
    ) -> List[mpf.make_addplot]:
        if not closed_trades:
            return []

        index = df_prices.index
        minutes = _timeframe_to_minutes(self.repository.timeframe)
        tolerance = pd.Timedelta(minutes=max(minutes or 5, 1))

        def _init_series() -> pd.Series:
            return pd.Series(np.nan, index=index)

        long_entries = _init_series()
        long_exits = _init_series()
        short_entries = _init_series()
        short_exits = _init_series()

        for trade in closed_trades:
            entry_idx, entry_price = self._locate_trade_point(trade.get("entry_time"), trade.get("entry_price"), index, tolerance)
            exit_idx, exit_price = self._locate_trade_point(trade.get("exit_time"), trade.get("exit_price"), index, tolerance)
            direction = str(trade.get("direction", "LONG")).upper()

            if direction == "LONG":
                if entry_idx is not None:
                    long_entries.loc[entry_idx] = entry_price
                if exit_idx is not None:
                    long_exits.loc[exit_idx] = exit_price
            else:
                if entry_idx is not None:
                    short_entries.loc[entry_idx] = entry_price
                if exit_idx is not None:
                    short_exits.loc[exit_idx] = exit_price

        addplots: List[mpf.make_addplot] = []
        if not long_entries.isna().all():
            addplots.append(
                mpf.make_addplot(long_entries, type="scatter", markersize=self.scatter_size, marker="^", color="#2ca02c")
            )
        if not long_exits.isna().all():
            addplots.append(
                mpf.make_addplot(long_exits, type="scatter", markersize=self.scatter_size, marker="v", color="#1f77b4")
            )
        if not short_entries.isna().all():
            addplots.append(
                mpf.make_addplot(short_entries, type="scatter", markersize=self.scatter_size, marker="v", color="#d62728")
            )
        if not short_exits.isna().all():
            addplots.append(
                mpf.make_addplot(short_exits, type="scatter", markersize=self.scatter_size, marker="^", color="#ff7f0e")
            )
        return addplots

    @staticmethod
    def _locate_trade_point(
        timestamp_raw: Any,
        price_raw: Any,
        index: pd.Index,
        tolerance: pd.Timedelta,
    ) -> tuple[pd.Timestamp | None, float]:
        if timestamp_raw is None:
            return None, float("nan")
        timestamp = pd.to_datetime(timestamp_raw, errors="coerce")
        if pd.isna(timestamp):
            return None, float("nan")
        if timestamp.tzinfo is not None:
            try:
                timestamp = timestamp.tz_convert(None)
            except AttributeError:
                timestamp = timestamp.tz_localize(None)

        loc = index.get_indexer([timestamp], method="nearest")
        if loc.size == 0 or loc[0] == -1:
            return None, float("nan")
        candidate = index[loc[0]]
        if abs(candidate - timestamp) > tolerance:
            return None, float("nan")

        price = float(price_raw) if price_raw is not None else float("nan")
        return candidate, price

    @staticmethod
    def _format_summary(
        metadata: Dict[str, Any],
        prices: pd.DataFrame,
        trades: List[Dict[str, Any]],
    ) -> str:
        period_start = pd.to_datetime(metadata.get("start")) if metadata.get("start") else prices.index.min()
        period_end = pd.to_datetime(metadata.get("end")) if metadata.get("end") else prices.index.max()
        net_profit = float(metadata.get("net_profit", 0.0))
        return_pct = float(metadata.get("return_pct", 0.0))
        max_drawdown = float(metadata.get("max_drawdown", 0.0))
        total_trades = int(metadata.get("total_trades", len(trades)))
        win_rate = metadata.get("win_rate")

        summary_parts = [
            f"Period: {period_start.date()} â†’ {period_end.date()}",
            f"Closed Trades: {total_trades}",
            f"Net Profit: ${net_profit:,.2f}",
            f"Return: {return_pct * 100:.2f}%",
            f"Max Drawdown: {max_drawdown * 100:.2f}%",
        ]
        if win_rate is not None:
            summary_parts.append(f"Win Rate: {float(win_rate) * 100:.2f}%")
        return " | ".join(summary_parts)


# ----------------------------------------------------------------------
# Public entry points
# ----------------------------------------------------------------------

def launch_trade_visualizer(
    *,
    cache_dir: Path | str = "backtest_results",
    timeframe: str = "5m",
    style: str = "yahoo",
    window_size: tuple[int, int] = (1100, 800),
) -> None:
    """Launch the Tkinter GUI using the provided configuration."""

    repository = BacktestCacheRepository(cache_dir=cache_dir, timeframe=timeframe)
    root = tk.Tk()
    app = TradeVisualizerApp(root, repository, chart_style=style)
    width, height = window_size
    root.geometry(f"{width}x{height}")
    root.mainloop()


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Visualize cached backtest results in a candlestick GUI.")
    parser.add_argument("--cache-dir", default="backtest_results", help="Directory containing cached JSON files.")
    parser.add_argument("--timeframe", default="5m", help="Timeframe suffix to look for (default: 5m).")
    parser.add_argument("--style", default="yahoo", help="mplfinance style name (default: yahoo).")
    parser.add_argument(
        "--window-size",
        nargs=2,
        type=int,
        metavar=("WIDTH", "HEIGHT"),
        default=(1100, 800),
        help="Window size for the Tkinter application (default: 1100 800).",
    )
    parser.add_argument("--no-launch", action="store_true", help="Parse options and exit without launching the GUI.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.no_launch:
        print(
            "Visualization configured with cache_dir=%s, timeframe=%s, style=%s, window_size=%s"
            % (args.cache_dir, args.timeframe, args.style, tuple(args.window_size))
        )
        return 0

    launch_trade_visualizer(
        cache_dir=args.cache_dir,
        timeframe=args.timeframe,
        style=args.style,
        window_size=tuple(args.window_size),
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
