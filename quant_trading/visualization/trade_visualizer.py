"""Tkinter GUI for inspecting cached backtest results."""

from __future__ import annotations

import argparse
import json
import re
import tkinter as tk
from dataclasses import dataclass
from tkinter import messagebox, ttk
from pathlib import Path
from typing import Any, Dict, List, Sequence

import mplfinance as mpf
import numpy as np
import pandas as pd
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.lines import Line2D


@dataclass
class CachedBacktest:
    """Data bundle returned by :class:`BacktestCacheRepository`."""

    metadata: Dict[str, Any]
    prices: pd.DataFrame
    trades: List[Dict[str, Any]]


class BacktestCacheRepository:
    """Helper around the JSON files generated by the backtest CLI."""

    def __init__(
        self,
        cache_dir: Path | str = "backtest_results",
        strategy: str | None = None,
        timeframe: str | None = "5m",
    ) -> None:
        self.base_dir = Path(cache_dir)
        self.strategy: str | None = strategy.upper() if strategy else None
        self.timeframe: str | None = timeframe.strip().lower() if timeframe else None
        
        # Auto-detect strategy and timeframe if not provided
        available_strategies = self.list_strategies()
        if not available_strategies:
            return
        if self.strategy not in available_strategies:
            self.strategy = available_strategies[0]
            
        available_timeframes = self.list_timeframes()
        if not available_timeframes:
            return
        if self.timeframe not in available_timeframes:
            self.timeframe = available_timeframes[0]

    # ------------------------------------------------------------------
    # Discovery helpers
    # ------------------------------------------------------------------
    def list_strategies(self) -> List[str]:
        """List available strategies based on directory structure."""
        if not self.base_dir.exists():
            return []

        strategies: set[str] = set()
        
        # Check for new structure: backtest_results/STRATEGY/timeframe/
        for entry in self.base_dir.iterdir():
            if entry.is_dir():
                # Look for subdirectories with JSON files
                for subdir in entry.iterdir():
                    if subdir.is_dir() and any(subdir.glob("*_backtest.json")):
                        strategies.add(entry.name.upper())
                        break

        # Support legacy structure: backtest_results/timeframe/
        legacy_timeframes = set()
        for entry in self.base_dir.iterdir():
            if entry.is_dir() and any(entry.glob("*_backtest.json")):
                legacy_timeframes.add(entry.name.lower())
                
        # If we found legacy structure but no new structure, assume legacy is from default strategy
        if legacy_timeframes and not strategies:
            strategies.add("MACD")  # Assume legacy files are from MACD strategy
        
        return sorted(strategies)

    def list_timeframes(self) -> List[str]:
        """List available timeframes for the current strategy."""
        if not self.base_dir.exists():
            return []

        timeframes: set[str] = set()
        
        # Check new structure: backtest_results/STRATEGY/timeframe/
        if self.strategy:
            strategy_dir = self.base_dir / self.strategy
            if strategy_dir.exists():
                for entry in strategy_dir.iterdir():
                    if entry.is_dir() and any(entry.glob("*_backtest.json")):
                        timeframes.add(entry.name.lower())

        # Support legacy structure: backtest_results/timeframe/
        if not timeframes:
            for entry in self.base_dir.iterdir():
                if entry.is_dir() and any(entry.glob("*_backtest.json")):
                    timeframes.add(entry.name.lower())

        return sorted(timeframes)

    def set_strategy(self, strategy: str) -> None:
        """Change the active strategy."""
        self.strategy = strategy.upper()
        
    def set_timeframe(self, timeframe: str) -> None:
        """Change the active timeframe."""
        self.timeframe = timeframe.strip().lower()

    def _cache_dir(self) -> Path:
        """Get the directory containing cache files for current strategy/timeframe."""
        # New structure: backtest_results/STRATEGY/timeframe/
        if self.strategy and self.timeframe:
            new_path = self.base_dir / self.strategy / self.timeframe
            if new_path.exists():
                return new_path
        
        # Legacy structure: backtest_results/timeframe/
        if self.timeframe:
            legacy_path = self.base_dir / self.timeframe
            if legacy_path.exists():
                return legacy_path
                
        return self.base_dir

    def _filename_suffix(self) -> str:
        suffix = "_backtest.json"
        if self.timeframe:
            suffix = f"_{self.timeframe}_backtest.json"
        return suffix

    def list_symbols(self) -> List[str]:
        """List available symbols for current strategy/timeframe."""
        directory = self._cache_dir()
        if not directory.exists():
            return []

        suffix = self._filename_suffix()
        symbols: List[str] = []
        for path in sorted(directory.glob("*_backtest.json")):
            if suffix and not path.name.endswith(suffix):
                continue
            symbols.append(path.name.replace(suffix, "").upper())
        return symbols

    # ------------------------------------------------------------------
    # Loading helpers
    # ------------------------------------------------------------------
    def load(self, symbol: str) -> CachedBacktest:
        """Load cached backtest data for a symbol."""
        directory = self._cache_dir()
        cache_path = directory / f"{symbol.lower()}{self._filename_suffix()}"
        if not cache_path.exists():
            raise FileNotFoundError(
                f"Cached backtest not found for {symbol} ({cache_path}). "
                f"Strategy: {self.strategy}, Timeframe: {self.timeframe}. "
                "Run 'python -m quant_trading.backtesting.run_backtest' to generate the data first."
            )

        with cache_path.open("r", encoding="utf-8") as handle:
            raw = json.load(handle)

        metadata = self._extract_metadata(raw)
        prices = self._build_price_frame(raw.get("candles"), symbol)
        trades = raw.get("closed_trades", [])
        return CachedBacktest(metadata=metadata, prices=prices, trades=trades)

    @staticmethod
    def _extract_metadata(payload: Dict[str, Any]) -> Dict[str, Any]:
        keys = {
            "symbol",
            "timeframe",
            "start",
            "end",
            "initial_capital",
            "ending_equity",
            "net_profit",
            "return_pct",
            "max_drawdown",
            "total_trades",
            "win_rate",
        }
        return {key: payload.get(key) for key in keys}

    def _build_price_frame(self, candles: List[Dict[str, Any]] | None, symbol: str) -> pd.DataFrame:
        if not candles:
            raise ValueError(
                f"Cached backtest for {symbol} does not contain candle data. "
                "Regenerate cache by re-running 'python -m quant_trading.backtesting.run_backtest'."
            )

        frame = pd.DataFrame(candles)
        if frame.empty:
            raise ValueError(f"Cached candle data for {symbol} is empty.")
        if "datetime" not in frame.columns:
            raise ValueError(f"Cached candle data for {symbol} is missing the 'datetime' column.")

        frame["datetime"] = pd.to_datetime(frame["datetime"], errors="coerce")
        frame = frame.dropna(subset=["datetime"]).sort_values("datetime").set_index("datetime")

        rename_map = {
            "open": "Open",
            "high": "High",
            "low": "Low",
            "close": "Close",
            "volume": "Volume",
        }
        missing = [column for column in rename_map if column not in frame.columns]
        if missing:
            raise ValueError(f"Cached candle data for {symbol} is missing columns: {missing}")

        prices = frame[list(rename_map.keys())].rename(columns=rename_map)
        for col in prices.columns:
            prices[col] = pd.to_numeric(prices[col], errors="coerce")
        prices = prices.dropna(subset=["Close"])
        if prices.empty:
            raise ValueError(f"Cached candle data for {symbol} does not contain valid price rows.")
        return prices


def _timeframe_to_minutes(timeframe: str | None) -> int | None:
    if not timeframe:
        return None
    match = re.match(r"(\d+)([a-zA-Z]+)", timeframe.strip())
    if not match:
        return None
    value = int(match.group(1))
    unit = match.group(2).lower()
    if unit in {"m", "min", "mins", "minute", "minutes"}:
        return value
    if unit in {"h", "hour", "hours"}:
        return value * 60
    if unit in {"d", "day", "days"}:
        return value * 60 * 24
    return None


class TradeVisualizerApp:
    """Tkinter-based candlestick visualizer for backtested trades."""

    def __init__(
        self,
        root: tk.Tk,
        repository: BacktestCacheRepository,
    *,
    chart_style: str = "yahoo",
    scatter_size: int = 10,
    ) -> None:
        self.root = root
        self.repository = repository
        self.chart_style = chart_style
        self.scatter_size = scatter_size
        self.root.protocol("WM_DELETE_WINDOW", self._on_close)

        # Initialize strategy options
        self.strategies = sorted(set(repository.list_strategies()))
        if not self.strategies:
            messagebox.showerror(
                "No Data",
                (
                    "No cached backtest files were found under "
                    f"{repository.base_dir}. Please run a backtest first."
                ),
            )
            return

        initial_strategy = repository.strategy or (self.strategies[0] if self.strategies else "")
        self.strategy_var = tk.StringVar(value=initial_strategy)

        # Initialize timeframe options
        self.timeframes = sorted(set(repository.list_timeframes()))
        if not self.timeframes:
            default_tf = repository.timeframe or ""
            if default_tf:
                self.timeframes = [default_tf]

        initial_timeframe = repository.timeframe or (self.timeframes[0] if self.timeframes else "")
        if initial_timeframe and initial_timeframe not in self.timeframes:
            self.timeframes.insert(0, initial_timeframe)

        self.timeframe_var = tk.StringVar(value=initial_timeframe)
        
        # Initialize symbols
        self.symbols = repository.list_symbols()
        self.symbol_var = tk.StringVar(value=self.symbols[0] if self.symbols else "")
        self.summary_var = tk.StringVar(value="Select a strategy, timeframe, and symbol, then click 'Load Chart'.")
        self.canvas: FigureCanvasTkAgg | None = None

        self._build_layout()

    # ------------------------------------------------------------------
    # UI construction
    # ------------------------------------------------------------------
    def _build_layout(self) -> None:
        control_frame = ttk.Frame(self.root, padding=10)
        control_frame.pack(fill=tk.X)

        # Strategy selector
        ttk.Label(control_frame, text="Strategy:").pack(side=tk.LEFT)
        self.strategy_combo = ttk.Combobox(
            control_frame,
            textvariable=self.strategy_var,
            values=self.strategies,
            state="readonly",
            width=8,
        )
        self.strategy_combo.pack(side=tk.LEFT, padx=(0, 10))
        self.strategy_combo.bind("<<ComboboxSelected>>", self._on_strategy_changed)

        # Timeframe selector
        ttk.Label(control_frame, text="Timeframe:").pack(side=tk.LEFT)
        self.timeframe_combo = ttk.Combobox(
            control_frame,
            textvariable=self.timeframe_var,
            values=self.timeframes,
            state="readonly",
            width=6,
        )
        self.timeframe_combo.pack(side=tk.LEFT, padx=(0, 10))
        self.timeframe_combo.bind("<<ComboboxSelected>>", self._on_timeframe_changed)

        # Symbol selector  
        ttk.Label(control_frame, text="Symbol:").pack(side=tk.LEFT)
        self.symbol_combo = ttk.Combobox(
            control_frame,
            textvariable=self.symbol_var,
            values=self.symbols,
            state="readonly",
            width=10,
        )
        self.symbol_combo.pack(side=tk.LEFT, padx=(0, 10))

        load_btn = ttk.Button(control_frame, text="Load Chart", command=self._on_load_clicked)
        load_btn.pack(side=tk.LEFT)

        self.summary_label = ttk.Label(self.root, textvariable=self.summary_var, padding=(10, 5))
        self.summary_label.pack(fill=tk.X)

        self.chart_frame = ttk.Frame(self.root)
        self.chart_frame.pack(fill=tk.BOTH, expand=True)

    # ------------------------------------------------------------------
    # Core functionality
    # ------------------------------------------------------------------
    def _on_load_clicked(self) -> None:
        symbol = self.symbol_var.get().strip().upper()
        if not symbol:
            messagebox.showwarning("Select Symbol", "Please choose a symbol before loading the chart.")
            return

        try:
            cached = self.repository.load(symbol)
        except FileNotFoundError as exc:
            messagebox.showerror("Cache Missing", str(exc))
            return
        except json.JSONDecodeError as exc:
            messagebox.showerror("Cache Error", f"Failed to parse cached backtest for {symbol}: {exc}")
            return
        except ValueError as exc:
            messagebox.showerror("Cache Error", str(exc))
            return

        addplots, marker_flags = self._build_trade_markers(cached.prices, cached.trades)
        self._render_chart(symbol, cached.prices, addplots, marker_flags)
        self.summary_var.set(self._format_summary(cached.metadata, cached.prices, cached.trades))

    def _on_strategy_changed(self, _: Any) -> None:
        """Handle strategy selection change."""
        strategy = self.strategy_var.get()
        self.repository.set_strategy(strategy)
        
        # Update timeframes for the new strategy
        self.timeframes = sorted(set(self.repository.list_timeframes()))
        self.timeframe_combo["values"] = self.timeframes
        if self.timeframes:
            self.timeframe_var.set(self.timeframes[0])
            self.repository.set_timeframe(self.timeframes[0])
        
        # Update symbols for the new strategy/timeframe
        self.symbols = self.repository.list_symbols()
        self.symbol_combo["values"] = self.symbols
        if self.symbols:
            self.symbol_var.set(self.symbols[0])
            self.summary_var.set("Select a symbol and click 'Load Chart'.")
        else:
            self.symbol_var.set("")
            self.summary_var.set("No data available for selected strategy.")

    def _on_timeframe_changed(self, _: Any) -> None:
        timeframe = self.timeframe_var.get()
        self.repository.set_timeframe(timeframe)
        self.symbols = self.repository.list_symbols()
        self.symbol_combo["values"] = self.symbols

        if self.symbols:
            self.symbol_var.set(self.symbols[0])
            self.summary_var.set("Select a symbol and click 'Load Chart'.")
        else:
            self.symbol_var.set("")
            messagebox.showwarning(
                "No Symbols",
                (
                    "No cached backtests were found for timeframe "
                    f"'{timeframe}' under {(self.repository.base_dir / timeframe).resolve()}."
                ),
            )

    # ------------------------------------------------------------------
    # Charting helpers
    # ------------------------------------------------------------------
    def _render_chart(
        self,
        symbol: str,
        df_prices: pd.DataFrame,
        addplots: List[mpf.make_addplot],
        marker_flags: Dict[str, bool] | None = None,
    ) -> None:
        fig, axes = mpf.plot(
            df_prices,
            type="candle",
            volume=True,
            style=self.chart_style,
            addplot=addplots,
            title=f"{symbol} {self.repository.timeframe.upper()} Candlesticks & Trades",
            ylabel="Price",
            ylabel_lower="Volume",
            returnfig=True,
            figsize=(12, 8),
        )

        price_ax = None
        if isinstance(axes, dict):
            price_ax = axes.get("main") or next(iter(axes.values()), None)
        elif isinstance(axes, (list, tuple)):
            price_ax = axes[0] if axes else None
        else:
            price_ax = axes

        if price_ax is not None:
            flags = marker_flags or {}
            legend_specs = [
                ("Long Entry", "#2ca02c", flags.get("long_entry", False)),
                ("Long Exit", "#1f77b4", flags.get("long_exit", False)),
                ("Short Entry", "#d62728", flags.get("short_entry", False)),
                ("Short Exit", "#ff7f0e", flags.get("short_exit", False)),
            ]
            handles: List[Line2D] = []
            marker_size = max(int(self.scatter_size * 0.7), 4)
            for label, color, enabled in legend_specs:
                if enabled:
                    handles.append(
                        Line2D(
                            [],
                            [],
                            marker="o",
                            linestyle="",
                            markerfacecolor=color,
                            markeredgecolor=color,
                            markersize=marker_size,
                            label=label,
                        )
                    )
            if handles:
                price_ax.legend(handles=handles, loc="upper left", frameon=False)

        if self.canvas is not None:
            self.canvas.get_tk_widget().destroy()

        self.canvas = FigureCanvasTkAgg(fig, master=self.chart_frame)
        self.canvas.draw()
        self.canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)

    def _build_trade_markers(
        self,
        df_prices: pd.DataFrame,
        closed_trades: List[Dict[str, Any]],
    ) -> tuple[List[mpf.make_addplot], Dict[str, bool]]:
        if not closed_trades:
            return [], {
                "long_entry": False,
                "long_exit": False,
                "short_entry": False,
                "short_exit": False,
            }

        index = df_prices.index
        minutes = _timeframe_to_minutes(self.repository.timeframe)
        tolerance = pd.Timedelta(minutes=max(minutes or 5, 1))

        def _init_series() -> pd.Series:
            return pd.Series(np.nan, index=index)

        long_entries = _init_series()
        long_exits = _init_series()
        short_entries = _init_series()
        short_exits = _init_series()

        for trade in closed_trades:
            entry_idx, entry_price = self._locate_trade_point(trade.get("entry_time"), trade.get("entry_price"), index, tolerance)
            exit_idx, exit_price = self._locate_trade_point(trade.get("exit_time"), trade.get("exit_price"), index, tolerance)
            direction = str(trade.get("direction", "LONG")).upper()

            if direction == "LONG":
                if entry_idx is not None:
                    long_entries.loc[entry_idx] = entry_price
                if exit_idx is not None:
                    long_exits.loc[exit_idx] = exit_price
            else:
                if entry_idx is not None:
                    short_entries.loc[entry_idx] = entry_price
                if exit_idx is not None:
                    short_exits.loc[exit_idx] = exit_price

        markers_present = {
            "long_entry": not long_entries.isna().all(),
            "long_exit": not long_exits.isna().all(),
            "short_entry": not short_entries.isna().all(),
            "short_exit": not short_exits.isna().all(),
        }

        addplots: List[mpf.make_addplot] = []
        if markers_present["long_entry"]:
            addplots.append(
                mpf.make_addplot(long_entries, type="scatter", markersize=self.scatter_size, marker="o", color="#2ca02c")
            )
        if markers_present["long_exit"]:
            addplots.append(
                mpf.make_addplot(long_exits, type="scatter", markersize=self.scatter_size, marker="o", color="#1f77b4")
            )
        if markers_present["short_entry"]:
            addplots.append(
                mpf.make_addplot(short_entries, type="scatter", markersize=self.scatter_size, marker="o", color="#d62728")
            )
        if markers_present["short_exit"]:
            addplots.append(
                mpf.make_addplot(short_exits, type="scatter", markersize=self.scatter_size, marker="o", color="#ff7f0e")
            )
        return addplots, markers_present

    def _on_close(self) -> None:
        if self.canvas is not None:
            try:
                self.canvas.figure.clf()
                self.canvas.get_tk_widget().destroy()
            except Exception:
                pass
            self.canvas = None

        try:
            self.root.quit()
        finally:
            try:
                self.root.destroy()
            except tk.TclError:
                pass

    @staticmethod
    def _locate_trade_point(
        timestamp_raw: Any,
        price_raw: Any,
        index: pd.Index,
        tolerance: pd.Timedelta,
    ) -> tuple[pd.Timestamp | None, float]:
        if timestamp_raw is None:
            return None, float("nan")
        timestamp = pd.to_datetime(timestamp_raw, errors="coerce")
        if pd.isna(timestamp):
            return None, float("nan")
        if timestamp.tzinfo is not None:
            try:
                timestamp = timestamp.tz_convert(None)
            except AttributeError:
                timestamp = timestamp.tz_localize(None)

        loc = index.get_indexer([timestamp], method="nearest")
        if loc.size == 0 or loc[0] == -1:
            return None, float("nan")
        candidate = index[loc[0]]
        if abs(candidate - timestamp) > tolerance:
            return None, float("nan")

        price = float(price_raw) if price_raw is not None else float("nan")
        return candidate, price

    @staticmethod
    def _format_summary(
        metadata: Dict[str, Any],
        prices: pd.DataFrame,
        trades: List[Dict[str, Any]],
    ) -> str:
        period_start = pd.to_datetime(metadata.get("start")) if metadata.get("start") else prices.index.min()
        period_end = pd.to_datetime(metadata.get("end")) if metadata.get("end") else prices.index.max()
        net_profit = float(metadata.get("net_profit", 0.0))
        return_pct = float(metadata.get("return_pct", 0.0))
        max_drawdown = float(metadata.get("max_drawdown", 0.0))
        total_trades = int(metadata.get("total_trades", len(trades)))
        win_rate = metadata.get("win_rate")

        summary_parts = [
            f"Period: {period_start.date()} â†’ {period_end.date()}",
            f"Closed Trades: {total_trades}",
            f"Net Profit: ${net_profit:,.2f}",
            f"Return: {return_pct * 100:.2f}%",
            f"Max Drawdown: {max_drawdown * 100:.2f}%",
        ]
        if win_rate is not None:
            summary_parts.append(f"Win Rate: {float(win_rate) * 100:.2f}%")
        return " | ".join(summary_parts)


# ----------------------------------------------------------------------
# Public entry points
# ----------------------------------------------------------------------

def launch_trade_visualizer(
    *,
    cache_dir: Path | str = "backtest_results",
    timeframe: str = "5m",
    style: str = "yahoo",
    window_size: tuple[int, int] = (1100, 800),
) -> None:
    """Launch the Tkinter GUI using the provided configuration."""

    repository = BacktestCacheRepository(cache_dir=cache_dir, timeframe=timeframe)
    root = tk.Tk()
    app = TradeVisualizerApp(root, repository, chart_style=style)
    width, height = window_size
    root.geometry(f"{width}x{height}")
    try:
        root.mainloop()
    finally:
        try:
            root.destroy()
        except tk.TclError:
            pass


def build_parser() -> argparse.ArgumentParser:
    parser = argparse.ArgumentParser(description="Visualize cached backtest results in a candlestick GUI.")
    parser.add_argument("--cache-dir", default="backtest_results", help="Directory containing cached JSON files (organized as STRATEGY/TIMEFRAME/).")
    parser.add_argument("--timeframe", default="5m", help="Default timeframe to display (default: 5m).")
    parser.add_argument("--style", default="yahoo", help="mplfinance style name (default: yahoo).")
    parser.add_argument(
        "--window-size",
        nargs=2,
        type=int,
        metavar=("WIDTH", "HEIGHT"),
        default=(1100, 800),
        help="Window size for the Tkinter application (default: 1100 800).",
    )
    parser.add_argument("--no-launch", action="store_true", help="Parse options and exit without launching the GUI.")
    return parser


def main(argv: Sequence[str] | None = None) -> int:
    parser = build_parser()
    args = parser.parse_args(argv)

    if args.no_launch:
        print(
            "Visualization configured with cache_dir=%s, timeframe=%s, style=%s, window_size=%s"
            % (args.cache_dir, args.timeframe, args.style, tuple(args.window_size))
        )
        return 0

    launch_trade_visualizer(
        cache_dir=args.cache_dir,
        timeframe=args.timeframe,
        style=args.style,
        window_size=tuple(args.window_size),
    )
    return 0


if __name__ == "__main__":
    raise SystemExit(main())
